"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fileExists = fileExists;
exports.hasTypeScript = hasTypeScript;
exports.WebpackConfigHelper = void 0;

var _cleanWebpackPlugin = _interopRequireDefault(require("clean-webpack-plugin"));

var _fs = _interopRequireDefault(require("fs"));

var _miniCssExtractPlugin = _interopRequireDefault(require("mini-css-extract-plugin"));

var _path = _interopRequireDefault(require("path"));

var _WatchMissingNodeModulesPlugin = _interopRequireDefault(require("react-dev-utils/WatchMissingNodeModulesPlugin"));

var _slugify = _interopRequireDefault(require("slugify"));

var _timeFixPlugin = _interopRequireDefault(require("time-fix-plugin"));

var _webpack = _interopRequireDefault(require("webpack"));

var _webpackAssetsManifest = _interopRequireDefault(require("webpack-assets-manifest"));

var _WpackioError = require("../errors/WpackioError");

var _babelConfig = require("./babelConfig");

var _fileLoader = require("./fileLoader");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Check if file exists or not using fs API.
 */
function fileExists(filepath) {
  try {
    // tslint:disable-next-line:non-literal-fs-path
    return _fs.default.statSync(filepath).isFile();
  } catch (_) {
    return false;
  }
}

function hasTypeScript(cwd) {
  const tsconfigPath = _path.default.resolve(cwd, './tsconfig.json');

  return [fileExists(tsconfigPath), tsconfigPath];
}
/**
 * A helper class to get different configuration of webpack.
 */


class WebpackConfigHelper {
  // This is where all the filename will be prefixed, so we create a directory
  // Actual outputPath as provided by user

  /**
   * Context directory, from where we read the stuff and put stuff.
   */

  /**
   * Simulated NODE_ENV string, used internally and defined
   * in webpack with webpack.DefinePlugin.
   */

  /**
   * Create an instance of GetEntryAndOutput class.
   */
  constructor(file, config, cwd, isDev = true) {
    _defineProperty(this, "appDir", void 0);

    _defineProperty(this, "outputPath", void 0);

    _defineProperty(this, "file", void 0);

    _defineProperty(this, "isDev", void 0);

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "cwd", void 0);

    _defineProperty(this, "env", void 0);

    this.file = file;
    this.config = config;
    this.cwd = cwd;
    this.isDev = isDev;

    if (isDev) {
      this.env = 'development';
    } else {
      this.env = 'production';
    } // Create the outputPath, because we would be needing that


    const {
      outputPath
    } = this.config; // and filename and inner directory name
    // this innerDir will be prefixed to all filename
    // because for multi-compiler to work, we need
    // outputPath and publicPath themselves on the same path.
    // all middlewares would actually use the `name` from webpack config
    // to separate updates.

    const {
      name
    } = this.file;
    this.appDir = (0, _slugify.default)(name, {
      lower: true
    });
    this.outputPath = _path.default.join(this.cwd, outputPath);
  }
  /**
   * Get webpack compatible entry configuration.
   *
   * The entry object has members which always has string[].
   * This is to ensure that we can insert the hot loader client
   * when necessary.
   */


  getEntry() {
    // First destructure away the stuff we need
    const {
      name,
      entry
    } = this.file; // We intend to pass the entry directly to webpack,
    // but, we need to add the hot-middleware client to the entry
    // else it will simply not work

    const normalizedEntry = {}; // Loop over all user defined entries and add to the normalizedEntry

    Object.keys(entry).forEach(key => {
      // We have to break and take the value in a separate
      // variable, otherwise typescript says all the weird
      // thing ðŸ˜¢
      const entryPoint = entry[key];
      normalizedEntry[key] = Array.isArray(entryPoint) ? // maybe we can go a step futher and put an entry point which takes
      // care of the __webpack_public_path__
      // like `@wpackio/publicpath?outputPath=${this.config.outputPath}&appName=${this.config.appName}`
      entryPoint : [entryPoint];
    }); // Now, if in dev mode, then add the hot middleware client

    if (this.isDev) {
      // Custom overlay and it's styling
      const overlayStyles = {
        zIndex: 999999999,
        fontSize: '14px',
        fontFamily: 'Dank Mono, Operator Mono SSm, Operator Mono, Menlo, Consolas, monospace',
        padding: '32px 16px'
      }; // Define the hot client string
      // Here we need
      // 1. dynamicPublicPath - Because we intend to use __webpack_public_path__
      // we can not know if user is going to use it in development too, but maybe it doesn't need to be?
      // 2. overlay and overlayStypes - To enable overlay on errors, we don't need warnings here
      // 3. path - The output path, We need to make sure both server and client has the same value.
      // 4. name - Because it could be multicompiler

      const webpackHotClient = `webpack-hot-middleware/client?path=__wpackio&name=${name}&dynamicPublicPath=true${this.config.errorOverlay ? '&overlay=true' : ''}&reload=true&overlayStyles=${encodeURIComponent(JSON.stringify(overlayStyles))}`; // Now add to each of the entries
      // We don't know if user want to specifically disable for some, but let's
      // not think ahead of ourselves

      Object.keys(normalizedEntry).forEach(key => {
        normalizedEntry[key] = [...normalizedEntry[key], // put webpack hot client in the entry
        webpackHotClient];
      });
    } else {
      // Put the publicPath entry point
      Object.keys(normalizedEntry).forEach(key => {
        normalizedEntry[key] = [// We need it before any other entrypoint, otherwise it won't
        `@wpackio/entrypoint/lib/index`, ...normalizedEntry[key]];
      });
    }

    return normalizedEntry;
  }
  /**
   * Get webpack compatible output object.
   */


  getOutput() {
    // Assuming it is production
    const output = {
      // Here we create a directory inside the user provided outputPath
      // The name of the directory is the sluggified verion of `name`
      // of this configuration object.
      // Also here we assume, user has passed in the correct `relative`
      // path for `outputPath`. Otherwise this will break.
      // We do not use path.resolve, because we expect outputPath to be
      // relative. @todo: create a test here
      path: this.outputPath,
      filename: `${this.appDir}/${this.isDev ? '[name]' : '[name]-[contenthash:8]'}.js`,
      // leave blank because we would handle with free variable
      // __webpack_public_path__ in runtime.
      publicPath: '',
      // we need different jsonpFunction, it has to
      // be unique for every webpack config, otherwise
      // the later will override the previous
      // having combination of appName and file.name
      // kind of ensures that billions of devs, don't
      // override each other!!!!
      jsonpFunction: `wpackio${this.config.appName}${this.file.name}Jsonp`
    }; // Add the publicPath if it is in devMode

    if (this.isDev) {
      // This is calculated by CreateWebpackConfig
      // taking into consideration user's own value.
      // So, if WordPress defaults are changed, then
      // depending on wpackio.server.js, it will still
      // point to the right location. It only makes
      // dynamic import and some on-demand split-chunk
      // work.
      output.publicPath = this.config.publicPathUrl;
    }

    return output;
  }
  /**
   * Get WebPack plugins, depending on development or production
   */


  getPlugins() {
    // Add common plugins
    let plugins = [// Define env
    new _webpack.default.DefinePlugin({
      'process.env.NODE_ENV': JSON.stringify(this.env),
      'process.env.BABEL_ENV': JSON.stringify(this.env),
      // Our own access to project config from the modules
      // mainly needed for the publicPath entrypoint
      __WPACKIO__: {
        appName: JSON.stringify(this.config.appName),
        outputPath: JSON.stringify(this.config.outputPath)
      }
    }), // Clean dist directory
    new _cleanWebpackPlugin.default({
      verbose: false,
      cleanAfterEveryBuildPatterns: `${this.outputPath}/${this.appDir}`
    }), // Initiate mini css extract
    new _miniCssExtractPlugin.default({
      filename: `${this.appDir}/${this.isDev ? '[name]' : '[name]-[contenthash:8]'}.css`
    }), // Create Manifest for PHP Consumption
    new _webpackAssetsManifest.default({
      writeToDisk: true,
      output: `${this.outputPath}/${this.appDir}/manifest.json`,
      publicPath: ``,
      // We dont put ${this.config.outputPath}/ here because, PHP will pick it up anyway.
      entrypoints: true,
      entrypointsKey: 'wpackioEp'
    })]; // Add ts checker plugin if project has tsconfig.json

    const [isTs, tsconfigPath] = hasTypeScript(this.cwd);

    if (isTs && this.file.hasTypeScript !== false) {
      // dynamic require forktschecker otherwise it will throw error
      try {
        // eslint-disable-next-line import/no-extraneous-dependencies, global-require, @typescript-eslint/no-var-requires
        const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');

        plugins.push(new ForkTsCheckerWebpackPlugin({
          tsconfig: tsconfigPath,
          tslint: undefined,
          async: this.isDev,
          silent: true,
          formatter: 'codeframe',
          useTypescriptIncrementalApi: true,
          checkSyntacticErrors: true,
          formatterOptions: {
            highlightCode: true
          },
          reportFiles: this.file.typeWatchFiles ? this.file.typeWatchFiles : []
        }));
      } catch (e) {
        throw new _WpackioError.WpackioError('please install fork-ts-checker-webpack-plugin package');
      }
    } // Add development specific plugins


    if (this.isDev) {
      // Hot Module Replacement
      plugins.push(new _webpack.default.HotModuleReplacementPlugin()); // If you require a missing module and then `npm install` it, you still have
      // to restart the development server for Webpack to discover it. This plugin
      // makes the discovery automatic so you don't have to restart.
      // See https://github.com/facebook/create-react-app/issues/186

      plugins.push(new _WatchMissingNodeModulesPlugin.default(_path.default.resolve(this.cwd, './node_modules'))); // Add timewatch plugin to avoid multiple successive build
      // https://github.com/webpack/watchpack/issues/25

      plugins = [new _timeFixPlugin.default(), ...plugins];
    } else {
      // Add Production specific plugins
      const {
        bannerConfig
      } = this.config;
      const creditNote = '\n\nCompiled with the help of https://wpack.io\nA zero setup Webpack Bundler Script for WordPress';
      plugins.push( // Banner plugin
      new _webpack.default.BannerPlugin({
        entryOnly: false,
        raw: false,
        // Add to ts, tsx, css, scss, sass
        include: /\.((t|j)sx?|s?(c|a)ss)$/,
        banner: `
${bannerConfig.name}

@author ${bannerConfig.author}
@version ${bannerConfig.version}
@link ${bannerConfig.link}
@license ${bannerConfig.license}

Copyright (c) ${new Date().getFullYear()} ${bannerConfig.author}

${bannerConfig.copyrightText}${bannerConfig.credit ? creditNote : ''}`
      }));
    } // Return it


    return plugins;
  }
  /**
   * Get module object for webpack, depending on environment.
   */


  getModule() {
    const {
      hasReact,
      hasSass,
      hasFlow,
      hasLess
    } = this.config;
    const wpackioBabelOptions = {
      hasReact
    };
    const babelLoaderCacheOptions = {
      // This is a feature of `babel-loader` for webpack (not Babel itself).
      // It enables caching results in ./node_modules/.cache/babel-loader/
      // directory for faster rebuilds.
      cacheDirectory: true,
      cacheCompression: !this.isDev,
      compact: !this.isDev
    }; // check if babel.config.js is present

    const isBabelConfigPresent = this.config.useBabelConfig; // Push targets to babel-preset-env if this is dev
    // We target only the latest chrome and firefox for
    // greater speed

    if (this.isDev) {
      wpackioBabelOptions.presetEnv = {
        targets: {
          chrome: '69',
          firefox: '62',
          edge: '17'
        }
      };
    } // create the babel rules for es6+ code


    const jsPresets = (0, _babelConfig.getBabelPresets)((0, _babelConfig.overrideBabelPresetOptions)(wpackioBabelOptions, this.config.jsBabelPresetOptions), hasFlow ? 'flow' : undefined);
    const jsRules = {
      test: /\.m?jsx?$/,
      use: [{
        loader: 'babel-loader',
        options: isBabelConfigPresent ? _objectSpread({}, babelLoaderCacheOptions) : this.getOverrideWebpackRuleOptions(_objectSpread({
          presets: jsPresets,
          // disable babelrc and babel.config.js
          // as it could potentially break stuff
          // rather use the jsBabelOverride
          configFile: false,
          babelrc: false
        }, babelLoaderCacheOptions), this.config.jsBabelOverride)
      }],
      exclude: /(node_modules|bower_components)/
    }; // create the babel rules for typescript code

    const tsPresets = (0, _babelConfig.getBabelPresets)((0, _babelConfig.overrideBabelPresetOptions)(wpackioBabelOptions, this.config.tsBabelPresetOptions), 'typescript');
    const tsRules = {
      test: /\.tsx?$/,
      use: [{
        loader: 'babel-loader',
        options: isBabelConfigPresent ? _objectSpread({}, babelLoaderCacheOptions) : this.getOverrideWebpackRuleOptions(_objectSpread({
          presets: tsPresets,
          // disable babelrc and babel.config.js
          // as it could potentially break stuff
          // rather use the jsBabelOverride
          configFile: false,
          babelrc: false
        }, babelLoaderCacheOptions), this.config.tsBabelOverride)
      }],
      exclude: /(node_modules)/
    }; // Compile node_modules

    const nmJsRules = {
      test: /\.(js|mjs)$/,
      // we exclude @babel/runtime and core-js
      exclude: /(@babel(?:\/|\\{1,2})runtime)|(core-js)/,
      include: /node_modules/,
      use: [{
        loader: 'babel-loader',
        options: _objectSpread({}, babelLoaderCacheOptions, {
          // Babel assumes ES Modules, which isn't safe until CommonJS
          // dies. This changes the behavior to assume CommonJS unless
          // an `import` or `export` is present in the file.
          // https://github.com/webpack/webpack/issues/4039#issuecomment-419284940
          sourceType: 'unambiguous',
          // preset from our own package
          presets: (0, _babelConfig.getBabelPresets)({
            hasReact: false
          }),
          // If an error happens in a package, it's possible to be
          // because it was compiled. Thus, we don't want the browser
          // debugger to show the original code. Instead, the code
          // being evaluated would be much more helpful.
          sourceMaps: false,
          // disable babelrc and babel.config.js for node_modules
          configFile: false,
          babelrc: false
        })
      }]
    }; // Create style rules

    const styleRulesUse = [this.isDev ? 'style-loader' : {
      loader: _miniCssExtractPlugin.default.loader,
      options: {
        sourceMap: true
      }
    }, {
      loader: 'css-loader',
      options: {
        importLoaders: 1,
        sourceMap: true
      }
    }, {
      loader: 'postcss-loader',
      options: {
        sourceMap: true
      }
    }]; // Create style rules

    const styleRules = [{
      test: /\.css$/,
      use: [...styleRulesUse]
    }]; // If we have sass, then add the stuff

    if (hasSass) {
      styleRules.push({
        test: /\.s(a|c)ss$/,
        use: [...styleRulesUse, {
          loader: 'sass-loader',
          options: {
            sourceMap: true
          }
        }]
      });
    } // If we have less, then add the stuff


    if (hasLess) {
      styleRules.push({
        test: /\.less$/,
        use: [...styleRulesUse, {
          loader: 'less-loader',
          options: {
            sourceMap: true,
            javascriptEnabled: true
          }
        }]
      });
    } // create file rules


    const {
      fileRulesNonStyle,
      fileRulesStyle
    } = (0, _fileLoader.getFileLoaderForJsAndStyleAssets)(this.appDir, this.isDev);
    return {
      rules: [jsRules, tsRules, nmJsRules, ...styleRules, fileRulesNonStyle, fileRulesStyle]
    };
  }
  /**
   * Get webpack compatible resolve property.
   */


  getResolve() {
    return {
      extensions: ['.js', '.jsx', '.ts', '.tsx'],
      alias: this.config.alias !== undefined ? _objectSpread({}, this.config.alias) : {}
    };
  }
  /**
   * Get optimization for webpack.
   *
   * We optimize all chunks because
   */


  getOptimization() {
    const {
      optimizeSplitChunks
    } = this.config;
    const optimization = {
      // We set runtimeChunk to be single
      // because user can (and probably should)
      // have multiple entry-point on the same page
      runtimeChunk: 'single'
    };

    if (optimizeSplitChunks) {
      optimization.splitChunks = {
        chunks: 'all',
        minSize: 30000,
        minChunks: 1,
        maxAsyncRequests: 5,
        maxInitialRequests: 3,
        name: true,
        cacheGroups: {
          vendors: {
            test: /[\\/]node_modules[\\/]/,
            priority: -10
          },
          default: {
            minChunks: 2,
            priority: -20,
            reuseExistingChunk: true
          }
        }
      };
    }

    return optimization;
  }
  /**
   * Get common configuration, depending on just environment.
   */


  getCommon() {
    return {
      context: this.cwd,
      devtool: this.isDev ? 'cheap-module-eval-source-map' : 'source-map',
      target: 'web',
      watch: this.isDev,
      mode: this.env,
      name: this.file.name,
      externals: this.config.externals
    };
  }
  /**
   * Get final loader option based on user and system.
   *
   * @param defaults Default options as calculated by system.
   * @param override User defined option.
   */


  getOverrideWebpackRuleOptions(defaults, override) {
    // If override is not undefined or null, then return it
    if (override !== undefined) {
      // If it is a function
      if (typeof override === 'function') {
        return override(defaults || {});
      }

      return override;
    } // Otherwise just return default


    return defaults;
  }
  /**
   * Get calculated app directory
   */


  getAppDir() {
    return this.appDir;
  }

}

exports.WebpackConfigHelper = WebpackConfigHelper;