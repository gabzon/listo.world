"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Server = void 0;

var _browserSync = _interopRequireDefault(require("browser-sync"));

var _devIp = _interopRequireDefault(require("dev-ip"));

var _formatWebpackMessages = _interopRequireDefault(require("react-dev-utils/formatWebpackMessages"));

var _typescriptFormatter = _interopRequireDefault(require("react-dev-utils/typescriptFormatter"));

var _openBrowser = _interopRequireDefault(require("react-dev-utils/openBrowser"));

var _webpack = _interopRequireDefault(require("webpack"));

var _webpackDevMiddleware = _interopRequireDefault(require("webpack-dev-middleware"));

var _webpackHotMiddleware = _interopRequireDefault(require("webpack-hot-middleware"));

var _CreateWebpackConfig = require("../config/CreateWebpackConfig");

var _WebpackConfigHelper = require("../config/WebpackConfigHelper");

var _WpackioError = require("../errors/WpackioError");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Create a development server with file watching, hot reload and live reload.
 * Everything is done with browserSync and webpack middleware.
 */
class Server {
  /**
   * Create an instance.
   *
   * @param projectConfig Project configuration as recovered from user directory.
   * @param serverConfig Server configuration as recovered from user directory.
   */
  constructor(projectConfig, serverConfig, cwd, callbacks) {
    _defineProperty(this, "projectConfig", void 0);

    _defineProperty(this, "serverConfig", void 0);

    _defineProperty(this, "cwd", void 0);

    _defineProperty(this, "isServing", false);

    _defineProperty(this, "bs", void 0);

    _defineProperty(this, "devMiddlewares", void 0);

    _defineProperty(this, "webpackConfig", void 0);

    _defineProperty(this, "isBrowserOpened", false);

    _defineProperty(this, "firstCompileCompleted", false);

    _defineProperty(this, "callbacks", void 0);

    _defineProperty(this, "hasTs", void 0);

    _defineProperty(this, "tsConfigPath", void 0);

    _defineProperty(this, "priorFirstCompileTsMessage", []);

    _defineProperty(this, "openBrowser", () => {
      const serverUrl = this.getServerUrl();

      if (!this.isBrowserOpened && this.serverConfig.open) {
        (0, _openBrowser.default)(serverUrl);
        this.isBrowserOpened = true;
      }
    });

    _defineProperty(this, "addTsHooks", (compiler, plugin) => {
      const {
        beforeCompile,
        done
      } = compiler.hooks;
      const tsHooks = plugin.getCompilerHooks(compiler);
      let tsMessagesPromise;
      let tsMessagesResolver;
      let tsMessagesReject = null; // Tap before run begins on watch mode to create a new tsmessage promise

      beforeCompile.tap('wpackIoServerBeforeCompileTs', () => {
        // reject the previous message queue if any
        if (tsMessagesReject != null) {
          try {
            tsMessagesReject('overridden');
          } catch (e) {// do nothing
          }
        }

        tsMessagesPromise = new Promise((resolve, reject) => {
          tsMessagesResolver = msgs => resolve(msgs);

          tsMessagesReject = reject;
        });
      });
      tsHooks.receive.tap('afterTypeScriptCheck', (diagnostics, lints) => {
        const allMsgs = [...diagnostics, ...lints];

        const format = message => `${(0, _typescriptFormatter.default)(message, true)}`;

        tsMessagesResolver({
          errors: allMsgs.filter(msg => msg.severity === 'error').map(format),
          warnings: allMsgs.filter(msg => msg.severity === 'warning').map(format)
        });
      }); // Once compilation is done, then show the message

      done.tap('wpackIoServerDoneTs', async () => {
        if (this.firstCompileCompleted) {
          const delayedMsg = setTimeout(() => {
            this.callbacks.onTcStart();
          }, 100);

          try {
            const messages = await tsMessagesPromise;
            clearTimeout(delayedMsg);
            this.callbacks.onTcEnd(messages);
            this.callbacks.onWatching();
          } catch (e) {// do thing, since it was cancelled
          }
        } else {
          this.priorFirstCompileTsMessage.push(tsMessagesPromise);
        }
      });
    });

    _defineProperty(this, "addHooks", compiler => {
      // We tap into done and invalid hooks, which are present
      // in both single and multi-compiler instances.
      const {
        done,
        invalid
      } = compiler.hooks; // When compilation is done, call the callback

      done.tap('wpackIoServerDone', stats => {
        // don't do anything if firstCompile hasn't run
        if (this.firstCompileCompleted) {
          const raw = stats.toJson('verbose');
          const messages = (0, _formatWebpackMessages.default)(raw);

          if (!messages.errors.length && !messages.warnings.length) {
            // Here be pretty stuff.
            this.callbacks.done(stats);
          }

          if (messages.errors.length) {
            this.callbacks.onError(messages);
          } else if (messages.warnings.length) {
            this.callbacks.onWarn(messages);
          }

          this.callbacks.onEmit(stats);

          if (!this.hasTs) {
            this.callbacks.onWatching();
          }
        }
      }); // On compile start

      invalid.tap('wpackIoServerInvalid', () => {
        this.callbacks.invalid();
      }); // some additional work for typescript
      // heavily based on create-react-script
      // Some more hooks on typescript

      if (this.hasTs) {
        // try to get the fork ts checker webpack plugin
        let ForkTsCheckerWebpackPlugin;

        try {
          // eslint-disable-next-line global-require, import/no-extraneous-dependencies, @typescript-eslint/no-var-requires
          ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');
        } catch (e) {
          throw new _WpackioError.WpackioError('please install fork-ts-checker-webpack-plugin package');
        } // Now here's the tricky thing, it could be either single compiler
        // or multi-compiler


        if ('compilers' in compiler) {
          // It is a multi-compiler instance
          compiler.compilers.forEach(sCompiler => {
            this.addTsHooks(sCompiler, ForkTsCheckerWebpackPlugin);
          });
        } else {
          // single compiler instance, so just tap one
          this.addTsHooks(compiler, ForkTsCheckerWebpackPlugin);
        }
      }
    });

    this.projectConfig = projectConfig;
    this.serverConfig = serverConfig;
    this.cwd = cwd;
    this.callbacks = callbacks; // Override serverConfig host if it is undefined

    if (!this.serverConfig.host) {
      const possibleHost = (0, _devIp.default)();

      if (possibleHost) {
        // eslint-disable-next-line prefer-destructuring
        this.serverConfig.host = possibleHost[0];
      }
    } // Create the webpackConfig


    this.webpackConfig = new _CreateWebpackConfig.CreateWebpackConfig(this.projectConfig, this.serverConfig, this.cwd, true); // Check if project has typescript

    const [hasTs, tsConfigPath] = (0, _WebpackConfigHelper.hasTypeScript)(this.cwd);
    this.hasTs = hasTs;
    this.tsConfigPath = tsConfigPath;
  }
  /**
   * Serve the webpack/browserSync hybrid server.
   */


  serve() {
    // If server is already running, then throw
    if (this.isServing) {
      throw new Error('Can not serve while the server is already running.');
    } // Create browserSync Instance


    const bs = _browserSync.default.create(); // Init middleware and stuff


    const middlewares = [];
    const devMiddlewares = []; // We can have multi-compiler or single compiler, depending on the config
    // we get. And both of them works for dev and hot middleware.

    let compiler;

    if (this.webpackConfig.isMultiCompiler()) {
      compiler = (0, _webpack.default)(this.webpackConfig.getWebpackConfig());
    } else {
      compiler = (0, _webpack.default)(this.webpackConfig.getWebpackConfig());
    } // Apply only the done hook for the single/multi compiler
    // we pass as webpack.Compiler, because ts don't like it otherwise


    this.addHooks(compiler); // eslint-disable-next-line @typescript-eslint/no-object-literal-type-assertion

    const devMiddleware = (0, _webpackDevMiddleware.default)(compiler, {
      stats: false,
      publicPath: this.webpackConfig.getPublicPath(),
      logLevel: 'silent',
      logTime: false
    });
    const hotMiddleware = (0, _webpackHotMiddleware.default)(compiler, {
      // Now because we are already using publicPath(dynamicPublicPath = true) in client
      // we have to assume that it is prefixed. That's why we prefix it in the server too.
      // Because it could be multi-compiler, I guess it will just work fine since we are
      // passing in the `name` too, as documented.
      path: `${this.webpackConfig.getHmrPath()}`,
      // We don't want any noise
      log: false
    }); // Push them

    middlewares.push(devMiddleware);
    devMiddlewares.push(devMiddleware);
    middlewares.push(hotMiddleware); // Init browsersync
    // BS options

    let bsOptions = {
      logLevel: 'silent',
      port: this.serverConfig.port,
      ui: this.serverConfig.ui,
      proxy: {
        target: this.serverConfig.proxy
      },
      // Middleware for webpack hot reload
      middleware: middlewares,
      host: this.serverConfig.host,
      open: false,
      // We don't want to open right away
      notify: this.serverConfig.notify,
      snippetOptions: {
        whitelist: [// Add WP REST API
        '/wp-json/**', // Add AJAX calls
        '/wp-admin/admin-ajax.php']
      }
    };

    if (this.serverConfig.bsOverride) {
      bsOptions = _objectSpread({}, bsOptions, this.serverConfig.bsOverride);
    } // Open browser on first build


    devMiddleware.waitUntilValid(stats => {
      if (!this.firstCompileCompleted) {
        this.firstCompileCompleted = true;
        this.callbacks.firstCompile(stats); // Some stuff for async ts checking

        if (this.priorFirstCompileTsMessage.length) {
          const delayedMsg = setTimeout(() => {
            this.callbacks.onTcStart();
          }, 100);
          Promise.all(this.priorFirstCompileTsMessage).then(msgs => {
            clearTimeout(delayedMsg);
            msgs.forEach(msg => {
              this.callbacks.onTcEnd(msg);
              this.callbacks.onWatching();
            });
          });
        } else {
          this.callbacks.onWatching();
        }
      }

      this.openBrowser();
    });
    bs.init(bsOptions); // Watch for user defined files, when it changes, reload
    // When that change, reload

    if (this.projectConfig.watch) {
      bs.watch(this.projectConfig.watch).on('change', file => {
        this.callbacks.onBsChange(file);
        bs.reload();
      });
    } // We don't need to watch for manifest, because if user is changing
    // Config, then she does need to restart. It won't be picked up
    // automatically by node.
    // Mark server is running


    this.isServing = true; // Store the instances

    this.bs = bs;
    this.devMiddlewares = devMiddlewares;
  }
  /**
   * Get URL to network IP where the server is alive.
   */


  getServerUrl() {
    return `http:${this.webpackConfig.getServerUrl()}`;
  }
  /**
   * Get URL to browserSync UI.
   */


  getBsUiUrl() {
    const {
      host,
      ui
    } = this.serverConfig;

    if (!ui) {
      return false;
    }

    return `http://${host || 'localhost'}:${ui.port || '8080'}`;
  }
  /**
   * Open browser if not already opened and config says so.
   */


  /**
   * Stop the server and clean up all processes.
   */
  stop() {
    // throw if server is not running
    if (!this.isServing) {
      throw new Error('Can not stop if the server is not running already. Call server.serve() first.');
    } // First stop browserSync


    if (this.bs) {
      this.bs.exit();
    } // Now stop all webpack compiler


    if (this.devMiddlewares) {
      this.devMiddlewares.forEach(devMiddleware => {
        devMiddleware.close();
      });
    } // All good

  }
  /**
   * Recompile everything through webpack.
   */


  refresh() {
    // throw if server is not running
    if (!this.isServing) {
      throw new Error('Can not refresh if the server is not running already. Call server.serve() first.');
    } // Refresh all devMiddlewares


    if (this.devMiddlewares) {
      this.devMiddlewares.forEach(devMiddleware => {
        devMiddleware.invalidate();
      });
    } // We probably? don't need anything with browserSync?

  }

}

exports.Server = Server;